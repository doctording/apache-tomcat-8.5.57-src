{"./":{"url":"./","title":"Introduction","keywords":"","body":"apache-tomcat-8.5.57-src源码阅读笔记 Main Class org.apache.catalina.startup.Bootstrap VM options -Dcatalina.home=./ -Dcatalina.base=./ -Djava.endorsed.dirs=./endorsed -Djava.io.tmpdir=./temp -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djava.util.logging.config.file=./conf/logging.properties -Dfile.encoding=UTF-8 -Duser.region=us -Duser.language=en idea启动运行 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-07-31 23:24:36 "},"content/basic.html":{"url":"content/basic.html","title":"1 tomcat的配置和发布基础","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 Tomcat的发布配置 如何发布web服务 利用war包发布 Host下配置Context发布 tomcat配置基础知识 conf/server.xml配置文件结构 Tomcat的发布配置 如何发布web服务 利用war包发布 将SpringBoot项目发布成.war 项目来源：源码链接 将.war拷贝到源码的webapps目录下 启动源码，然后访问即可 Host下配置Context发布 Host下配置Context 启动源码，然后访问即可 tomcat配置基础知识 conf/server.xml配置文件结构 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-08-01 12:16:35 "},"content/start.html":{"url":"content/start.html","title":"2 tomcat源码启动流程","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 Tomcat启动流程&架构 源码启动流程分析 jvisualvm查看tomcat启动后的线程 自己设置线程池 附加：public abstract class LifecycleBase implements Lifecycle Tomcat启动流程&架构 源码启动流程分析 Bootstrap main Catlina load // Start the new server try { getServer().init(); } catch (LifecycleException e) { if (Boolean.getBoolean(\"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE\")) { throw new java.lang.Error(e); } else { log.error(\"Catalina.start\", e); } } @Override public final synchronized void init() throws LifecycleException { if (!state.equals(LifecycleState.NEW)) { invalidTransition(Lifecycle.BEFORE_INIT_EVENT); } try { setStateInternal(LifecycleState.INITIALIZING, null, false); initInternal(); setStateInternal(LifecycleState.INITIALIZED, null, false); } catch (Throwable t) { handleSubClassException(t, \"lifecycleBase.initFail\", toString()); } } StandardServer initInternal service.init(); StandardService initInternal engine.init(); StandardEngine initInternal getRealm connector.init(); Connector initInternal protocolHandler.init(); AbstractHttp11Protocol init // tomcat 8默认了NIO方式，控制台可以看到\"http-nio-8080\" AbstractProtocol init AbstractEndpoint init bind(); NioEndpoint bind // ServerSocketChannel // 默认设置：serverSock.configureBlocking(true); Catlina start StandardServer startInternal engine.start(); executor.start(); connector.start(); Connector startInternal AbstractProtocol start endpoint.start(); NioEndpoint startInternal Poller run selector.select // Selector处理事件 processKey(sk, attachment); // 处理SelectionKey processSocket(attachment, SocketEvent.OPEN_READ, true) // 处理请求 executor.execute(sc); processSocket(attachment, SocketEvent.OPEN_WRITE, true) // 响应返回 startAcceptorThreads // 默认一个acceptor线程 NioEndpoint的内部类Acceptor run方法 serverSock.accept(); setSocketOptions(socket); // 处理请求，且会重新`socket.configureBlocking(false)` 下图所示debug到NioEndpoint的bind方法 下图所示debug到NioEndpoint的创建 acceptor, poller threads 相关源码见：NioEndpoint类的startInternal方法 /** * Start the NIO endpoint, creating acceptor, poller threads. */ @Override public void startInternal() throws Exception { if (!running) { running = true; paused = false; processorCache = new SynchronizedStack<>(SynchronizedStack.DEFAULT_SIZE, socketProperties.getProcessorCache()); eventCache = new SynchronizedStack<>(SynchronizedStack.DEFAULT_SIZE, socketProperties.getEventCache()); nioChannels = new SynchronizedStack<>(SynchronizedStack.DEFAULT_SIZE, socketProperties.getBufferPool()); // Create worker collection if ( getExecutor() == null ) { createExecutor(); } initializeConnectionLatch(); // Start poller threads pollers = new Poller[getPollerThreadCount()]; for (int i=0; i jvisualvm查看tomcat启动后的线程 默认的一个Acceptor线程 2个Poller线程 同时看到了10个http-nio-8080-exex-线程,这是由于EndPoint默认设置的了private int minSpareThreads = 10; 自己设置线程池 --> 附加：public abstract class LifecycleBase implements Lifecycle Lifecycle接口统一管理Tomcat生命周期 public interface Lifecycle { // 13个状态常量值 public static final String BEFORE_INIT_EVENT = \"before_init\"; public static final String AFTER_INIT_EVENT = \"after_init\"; public static final String START_EVENT = \"start\"; public static final String BEFORE_START_EVENT = \"before_start\"; public static final String AFTER_START_EVENT = \"after_start\"; public static final String STOP_EVENT = \"stop\"; public static final String BEFORE_STOP_EVENT = \"before_stop\"; public static final String AFTER_STOP_EVENT = \"after_stop\"; public static final String AFTER_DESTROY_EVENT = \"after_destroy\"; public static final String BEFORE_DESTROY_EVENT = \"before_destroy\"; public static final String PERIODIC_EVENT = \"periodic\"; public static final String CONFIGURE_START_EVENT = \"configure_start\"; public static final String CONFIGURE_STOP_EVENT = \"configure_stop\"; // 3个监听器方法 public void addLifecycleListener(LifecycleListener listener); public LifecycleListener[] findLifecycleListeners(); public void removeLifecycleListener(LifecycleListener listener); // 4个生命周期方法 public void init() throws LifecycleException; public void start() throws LifecycleException; public void stop() throws LifecycleException; public void destroy() throws LifecycleException; // 2个当前状态方法 public LifecycleState getState(); public String getStateName(); ​LifecycleBase 类则是Lifecycle 接口的默认实现 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-08-01 16:57:07 "},"content/init.html":{"url":"content/init.html","title":"2 tomcat加载web项目和处理请求流程","keywords":"","body":"TreeviewCopyright @doctording all right reserved, powered by aleen42 Tomcat加载web项目和处理请求流程 跟踪请求处理流程 Tomcat加载web项目和处理请求流程 跟踪请求处理流程 直接断点打到Acceptor的processKey方法 浏览器发起请求 处理读请求 请求发到Servlet容器的service方法,所以直接HttpServlet service方法断点 请求栈（责任链模式） 请求通过线程池去执行，具体是NioEndPoint的doRun方法 会封装SocketWrapperBase,转发到Http11Processor处理 然后再交给Standard的Engine（Engine是一个Servlet容器）处理 Engine之后可以看到有Standard的Host,Context,Wrapper等处理，中间有各种Filter操作，最后是Servlet Servlet容器的HttpServlet类的service方法得到了具体的HttpRequest请求 请求处理和返回 Copyright @doctording all right reserved，powered by Gitbook该文件修改时间： 2020-08-01 18:45:54 "}}